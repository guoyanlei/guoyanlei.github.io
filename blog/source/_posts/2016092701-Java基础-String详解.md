---
title: Java基础-String详解
date: 2016-09-27 21:59:15
tags:
- Java基础
categories:
- Java基础
---

String、StringBuffer、StringBuilder是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题，特此总结一下。

## String是不可变类

一般认为：当对象一旦创建完成后，在正常情况下，对象的状态不会因外界的改变而改变（对象的状态是指对象的属性，包括属性的类型及属性值）。

看如下的例子：
```java
String s = "abc";
System.out.println("s:" + s);  // 输出s:abc
s = "def";
System.out.println("s:" + s);  // 输出s:def
```

例中s只是指向堆内存中的引用，存储的是对象在堆中的地址，而非对象本身，s本身存储在栈内存中。
实际上，此时堆内存中依然存在着"abc"和"def"对象。对于"abc"对象本身而言，对象的状态是没有发生任何变化的。

String类之所以是不可以变的，是因为String类中没有提供对外可用的setters方法。
阅读JDK1.7的源码：

```java
public final class String implements Serializable, Comparable<String>, CharSequence{
    /** The value is used for character storage. */
    private final char value[];
    /** Cache the hash code for the string */
    private int hash; // Default to 0
}
```

可见类名前面用了final class修饰，因此，String类不能被继承，属性value[]和hash都是被定义成private类型，且由于没有提供对外的public setters方法。
更重要的是value[]，其被final char修饰，因此字符型数组value只会被赋值一次就不可修改，它存储的正好是String的值。

<!-- more -->

## String字符串常量池

JVM为了提高性能和减少内存开销，内部维护了一个字符串常量池，每当创建字符串常量时，JVM首先检查字符串常量池，如果常量池中已经存在，则返回池中的字符串对象引用，否则创建该字符串对象并放入池中。

因此下述结果返回true。
```java
String a = "abc";
String b = "abc";
System.out.print(a == b); //true
```

其中a和b指向同一个字符串常量
但与创建字符串常量方式不同的是，当使用new String(String str)方式等创建字符串对象时，不管字符串常量池中是否有与此相同内容的字符串，都会在堆内存中创建新的字符串对象。
因此，下面代码片段有如下结果。

```java
String a = "Hello";
String b = new String("Hello");
System.out.println(a == b);  //false
System.out.println(a.equals(b)); //true
```

即使字符串内容相同，字符串常量池中的字符串与通过new String(..)等方式创建的字符串对象之间没有直接的关系，但是，可以通过字符串的intern()方法找到此种关联。intern()方法返回字符串对象在字符串常量池中的对象引用，若字符串常量池中尚未有此字符串，则创建一新的字符串常量放置于池中。
于是，很据如上理解，很自然的，可以得到如下结果。

```java
String a = "Hello";
System.out.println(a == a.intern()); //true
String b = new String("corn");
String c = b.intern();
System.out.println(b == c); //false
String d = "corn";
System.out.println(c == d); //true
```

## String中的 '+' 操作

例子：
```java
public static void main(String[] args) {
    String a = "aa";
    String b = "bb";
    String c = "xx" + "yy " + a + "zz" + "mm" + b;
    System.out.println(c);
}
```

通过字节码[编译过程](http://www.cnblogs.com/lwbqqyumidi/p/4060845.html)可以得出如下几点结论：

1. String中使用 + 字符串连接符进行字符串连接时，连接操作最开始时如果都是字符串常量，编译后将尽可能多的直接将字符串常量连接起来，形成新的字符串常量参与后续连接

2. 接下来的字符串连接是从左向右依次进行，对于不同的字符串，首先以最左边的字符串为参数创建StringBuilder对象，然后依次对右边进行append操作，最后将StringBuilder对象通过toString()方法转换成String对象（注意：中间的多个字符串常量不会自动拼接）。

即：
```java
String c = "xx" + "yy " + a + "zz" + "mm" + b;
实质上的实现过程是:
String c = new StringBuilder("xxyy").append(a).append("zz").append("mm").append(b).toString();
```

## String/StringBuilder/StringBuffer之间的区别

### 可变与不可变

String类中使用字符数组保存字符串，因为有“final”修饰符，所以string对象是不可变的。
StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，但是不是final的。
```java
private final char value[]; //String类
char[] value;  //AbstractStringBuilder类
```

### 是否多线程安全

String中的对象是不可变的，也就可以理解为常量，显然线程安全。
AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。
StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。源代码如下：

```java
public synchronized StringBuffer reverse() {
    super.reverse();
    return this;
}
public int indexOf(String str) {
    return indexOf(str, 0);        //存在 public synchronized int indexOf(String str, int fromIndex) 方法
}
```
StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

### StringBuilder与StringBuffer共同点

StringBuilder与StringBuffer有公共父类AbstractStringBuilder(抽象类)。

StringBuilder、StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(...)。只是StringBuffer会在方法上加synchronized关键字，进行同步。

**最后，如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。**


