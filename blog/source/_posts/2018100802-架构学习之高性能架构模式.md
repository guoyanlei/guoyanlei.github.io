title: 架构学习之高性能架构模式
date: 2018/10/08 15:30:00
tags:
- 架构
categories:
- 学架构

---

### 1、高性能数据库集群

#### 读写分离

> 基本原理是将数据库读写操作分散到不同的节点上。

- 主从：“从机”是需要提供读数据的功能的
- 主备：一般被认为仅仅提供备份功能，不提供访问功能

主从基本实现：

- 数据库服务器搭建主从集群，一主一从、一主多从都可以
- 数据库主机负责读写操作，从机只负责读操作。
- 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。
- 业务服务器将写操作发给数据库主机，将读操作发给数据库从机。

<!--more-->

需解决的问题：

- 复制延迟：数据同步延迟
 - 写操作后的读操作指定发给数据库主服务器
 - 读从机失败后再读一次主机
 - 关键业务读写操作全部指向主机，非关键业务采用读写分离
- 分配机制：将读写区分开
 - 程序代码封装（在代码中抽象一个数据访问层，Hibernate）
 - 中间件封装（独立一套系统出来，实现读写操作分离和数据库服务器连接的管理，MySQL Router）

总结：并不是说一有性能问题就上读写分离，而是应该先优化，例如优化慢查询，调整不合理的业务逻辑，引入缓存等，只有确定系统没有优化空间后，才考虑读写分离或者集群。

#### 分库分表

##### 业务分库

> 业务分库指的是按照业务模块将数据分散到不同的数据库服务器。

需注意的问题：

- JOIN操作问题
- 事务问题
- 成本问题

##### 分表

> 同一业务的单表数据进行拆分

- 垂直分表：拆分字段到不同的表
- 水平分表：拆分记录到不同的表

水平分表的路由问题：

- 范围路由：选取有序的数据列（例如，整形、时间戳等）作为路由的条件，不同分段分散到不同的数据库表中。
- Hash路由：选取某个列（或者某几个列组合也可以）的值进行Hash运算，然后根据 Hash 结果分散到不同的数据库表中。
- 配置路由：配置路由就是路由表，用一张独立的表来记录路由信息。

#### 高性能NoSQL

常见的NoSQL方案分为4类。

- K-V 存储：解决关系数据库无法存储数据结构的问题，以Redis为代表
 - Redis 的 Value 是具体的数据结构，包括string、hash、list、set、sorted set、bitmap 和 hyperloglog，常被称为数据结构服务器
 - Redis 的事务只能保证隔离性和一致性（I 和 C），无法保证原子性和持久性（A 和 D）
- 文档数据库：解决关系数据库强schema约束的问题，以MongoDB为代表
 - 新增字段简单，历史数据不回出错
 - 很容易存储复杂数据
 - 代价是不支持事物、无法实现关系数据库的 join 操作
- 列式数据库：解决关系数据库大数据场景下的I/O问题，以HBase为代表
 - 读取表中某些列时，只需要把需要的列读取到内存中（节省I/O）
 - 列式存储还具备更高的存储压缩比，能够节省更多的存储空间
 - 需要频繁地更新多个列时，磁盘是随机写操作，效率不高
- 全文搜索引擎：解决关系数据库的全文搜索性能问题，以Elasticsearch为代表
 - 技术原理被称为“倒排索引”，建立单词到文档的索引
 - 全文搜索引擎的索引对象是单词和文档，而关系数据库的索引对象是键和行

#### 高性能缓存

> 缓存就是为了弥补存储系统在复杂业务场景（经过复杂运算过的数据、读多写少等）下的不足，其基本原理是将可能重复使用的数据放到内存中，一次生成、多次使用，避免每次使用都去访问存储系统。

缓存架构的设计要点

##### 缓存穿透

> 缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。


##### 缓存雪崩

> 当缓存失效（过期）后引起系统性能急剧下降的情况。由于旧的缓存已经被清除，新的缓存还未生成，并且处理这些请求的线程都不知道另外有一个线程正在生成缓存，因此所有的请求都会去重新生成缓存，都会去访问存储系统，从而对存储系统造成巨大的性能压力。这些压力又会拖慢整个系统。

解放方法：

- 更新锁：对缓存更新操作进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或默认值。
- 后台更新：后台线程来更新缓存，而不是由业务线程来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存。

##### 缓存热点

> 如果大部分甚至所有的业务请求都命中同一份缓存数据，则这份数据所在的缓存服务器的压力也很大。

解决方法：复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力。（不同的缓存副本不要设置统一的过期时间，否则就会出现所有缓存副本同时生成同时失效的情况，从而引发缓存雪崩）

### 2、高性能服务器

- 尽量提升单服务器的性能，将单服务器的性能发挥到极致。
- 如果单服务器无法支撑性能，设计服务器集群方案。

#### 单服务器的高性能

> 单服务器高性能的关键之一就是设计服务器采取的 “并发模型”

- 服务器如何处理连接：I/O 模型：阻塞、非阻塞、同步、异步
- 服务器如何处理请求：进程模型：单进程、多进程、多线程

单服务器高性能模式（PPC 和 TPC 模式）：

- PPC（Process Per Connection）：指每次有新的连接就新建一个 “进程” 去专门处理这个连接的请求
- prefork：系统在启动的时候就预先创建好进程，然后才开始接受用户的请求，省去fork进程操作
- TPC（Thread Per Connection）：指每次有新的连接就新建一个 “线程” 去专门处理这个连接的请求
- prethread：预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作

单服务器高性能模式（Reactor 和 Proactor 模式）：

> 资源复用，即不再单独为每个连接创建进程，而是创建一个进程池，将连接分配给进程，一个进程可以处理多个连接的业务.

IO操作分两个阶段【去饭店点餐排队】：

- 1. 等待数据准备好(读到内核缓存) 【准备菜品】
- 2. 将数据从内核缓存读到用户空间(进程空间) 【端走吃到肚里】

一般来说1花费的时间远远大于2。 

- 同步阻塞IO：1上阻塞2上也阻塞【付完钱在收银台等着，菜好之后取走离开】
- 同步非阻塞IO：1上非阻塞2上阻塞（Reactor模型）【付完钱领号，等待叫号，自己来取】
- 异步非阻塞IO：1上非阻塞2上非阻塞是（Proactor模型）【付完钱领号，回到座位干别的，菜好后服务员把菜端来】


#### 服务器集群的高性能

> 高性能集群的复杂性：需要一个任务分配器（负载均衡），以及任务分配算法

##### 负载均衡

负载均衡的分类：

- DNS负载均衡：实现地理级别的均衡（简单、成本低）
- 硬件负载均衡：用于负载均衡的基础网络设备（价格昂贵、扩展能力差）
- 软件负载均衡：常见的Nginx（网络7层负载均衡）和 LVS（4层负载均衡）

DNS 负载均衡用于实现地理级别的负载均衡；硬件负载均衡用于实现集群级别的负载均衡；软件负载均衡用于实现机器级别的负载均衡。

##### 任务分配算法

- 轮询：按照顺序轮流分配到服务器上
- 加权轮询：根据服务器权重进行任务分配
- 负载最低优先：将任务分配给当前负载最低的服务器（站在服务器的角度）
- 性能最优类：优先将任务分配给处理速度最快的服务器（站在客户端的角度）
- Hash类：根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上


